//
//  main.cpp
//  DecisionTreeClassification
//
//  Created by Daryl Drake on 7/29/17.
//  Copyright Â© 2017 IcedOutIndustries. All rights reserved.
//

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>

using namespace std;


vector<string> getTuple(string input)
{
    string token, delimiter(",");
    vector<string> output;
    
    size_t pos = 0;
    while ((pos = input.find(delimiter)) != string::npos)
    {
        token = input.substr(0, pos);
        output.push_back(token);
        input.erase(0, pos + delimiter.length());
    }
    output.push_back(input);
    
    return output;
}

/*
 calculate the information, or entropy, of a given data partition for which
 the target attribute is the attrbiute at targetPosition.
 */
float info(vector<vector<string>> dataPartition, uint8_t targetPosition)
{
    map<string, float> targetCount;
    
    //find the counts for each value of the target attribute within the given data partition
    for(auto it = dataPartition.begin(); it != dataPartition.end(); it++)
    {
        targetCount[(*it).at(targetPosition)]++;
    }
    
    float currInfo;
    
    for(auto it = targetCount.begin(); it != targetCount.end(); it++)
    {
        //avoid log(0) case
        if((*it).second == 0.0)
            continue;
        
        float p = (*it).second / dataPartition.size();
        currInfo += (-1) * p * log2(p);
    }
    
    return currInfo;
}


//!!!!!!!!!!!
float infoA(vector<vector<string>> dataPartition, uint8_t attributePosition, uint8_t targetPosition)
{
    set<string> attributeValues;
    for(auto it = dataPartition.begin(); it != dataPartition.end(); it++)
    {
        attributeValues.insert((*it).at(attributePosition));
    }
    
    
    
    
    return 0.0;
}

/*
 return the potential information generated by splitting along the attribute. 
 analagous to entropy but we are looking at attribute splitting not target attributes
 */
float splitInfo(vector<vector<string>> dataPartition, uint8_t attributePosition)
{
    return info(dataPartition, attributePosition);
}


int main()
{
    cin.ignore();
    
    //get and ignore first line of data
    string input, targetAttribute;
    getline(cin, input);
    getline(cin, input);
    
    //get attributes and targetAttribute
    vector<string> attributes = getTuple(input);
    targetAttribute = attributes.back();
    
    //fill database with tuples
    vector<vector<string>> DB;
    
    while (getline(cin, input) && input.compare("end"))
    {
        DB.push_back(getTuple(input));
    }
    
    float information = info(DB, DB[0].size() - 1);
    
    float currMaxGain(0), currMaxRatio(0);
    uint8_t currMaxGainPos(0), currMaxRatioPos(0);
    
    //calcuate gain and gain ratio for each attribute and return the position of the attribute which maximizes both
    for(uint8_t i = 0; i < attributes.size() - 1; i++)
    {
        
        float tempGain = information - infoA(DB, i, DB[0].size() - 1);
        if(currMaxGain < tempGain)
        {
            currMaxGain = tempGain;
            currMaxGainPos = i;
        }
        
        float tempRatio = tempGain / splitInfo(DB, i);
        if(currMaxRatio < tempRatio)
        {
            currMaxRatio = tempRatio;
            currMaxRatioPos = i;
        }
    }
    
    cout << attributes.at(currMaxGainPos) << endl;
    cout << attributes.at(currMaxRatioPos) << endl;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return 420;
}
